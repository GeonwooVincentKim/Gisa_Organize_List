Clean Code 를 작성하기 위한 원칙으로 틀린 것 (No.21 -> 1)
1. 추상화 -> 하위 Class/메소드/함수 Application 특성 간략 표시, 상세 내용, 상위 Class/메소드/함수에서 구현
2. 의존성 -> 다른 모듈에 미치는 영향을 최소화하도록 작성
3. 가독성 -> 누구든지 읽기 쉽게 코드를 작성
4. 중복성 -> 중복 최소화 가능한 코드 작성

= 1. 추상회 -> 상위 Class; 프로그램 특성만 간략하게 App 특성 나타냄, 하위 Class; 세부적 내용 구현
= 2. 의존성 (배제) -> 다른 모듈에 미치는 영향 최소화, 코드 변경 시 영향이 가지 않도록
= 3. 중복성 (최소화) -> 코드 중복 최소화
= 4. 가독성 -> 누구든지 읽기 쉽게 작성
= 5. 단순성 -> 코드 단순하게 작성 (프로그램 최소 단위로 분리, 작업을 한 번에 하나씩 처리)

Unit Test 에서 Test 대상이 되는 하위 모듈 호출, Parameter 전달, 가상 모듈, 상향식 Test (No.22 -> 2)
1. Test Stub
2. Test Driver
3. Test Suites
4. Test Case

= 1. Test Stub -> 제어 모듈 호출, 타 모듈 기능 단순 수행 도구, 일시적으로 필요한 조건만 가지는 Test 용 모듈
= 2. Test Suites -> Test 대상 컴포넌트, 모듈, 시스템에 사용되는 TC 의 집합
= 3. Test Case -> 사용자 요구사항 정확 준수 여부 확인, Test 항목 명세서 (입력 값, 실행 조건, 기대 결과)
= 4. Stub -> 하향식, Driver -> 상향식

Stack 에 대한 옳은 내용으로만 나열된 것 (No.23 -> 3)
ㄱ -> FIFO 방식으로 처리
ㄴ -> 순서 List 의 뒤 (Rear) 에서 Node 가 삽입, 앞 (Front) 에서 Node 가 제거
ㄷ -> 선형 List 의 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료 구조
ㄹ -> 인터럽트 처리, 서브루틴 호출 작업 등에 응용

1. ㄱ, ㄴ
2. ㄴ, ㄷ
3. ㄹ
4. ㄱ, ㄴ, ㄷ, ㄹ

= 1. FIFO-Queue 방식 -> 한쪽에서 삽입과 삭제가 모두 이루어 짐
= 2. ㄴ -> Queue 방식
= 3. ㄷ -> Deque 설명
= 4. Stack 은 LIFO 방식으로 처리됨

SW 모듈화의 장점 아닌 것 (No.24 -> 2)
1. 오류 파급 효과 최소화
2. 기능 분리 가능, Interface 복잡
3. 모듈 재사용 가능, 개발과 유지보수 용이
4. 프로그램 효율적인 관리 가능

= 1. 프로그램 효율적 관리 & 이해 용이한 SW
= 2. SW 시험, 통합, 수정 시 용이 & 모듈 재사용 가능
= 3. 오류 파급력 최소화

SW 프로젝트 관리에 대한 설명으로 가장 옳은 것 (No.25 -> 4)
1. 개발에 따른 산출물 관리
2. 소요인력 최대화, 정책 결정 신속 처리
3. 주어진 기간 연장, 최소의 비용으로 시스템 개발
4. 주어진 기간 내 최소 비용으로 사용자 만족시키는 시스템 개발

= 1. 주어진 기간 내 최소 비용으로 사용자 만족시키는 시스템 개발, 전반적인 활동
= 2. SW 개발 계획 정립, 분석, 설계 구현 등 작업 통제, SW 생명주기 전 과정에 걸쳐 진행
= 3. SW 프로젝트를 성공적 수행, 수행할 작업 범위, 필요한 자원, 수행 업무, 이정표, 비용 추진 일정들을 잡아야 함
= 4. 소요인력 최소화
= 5. 프로젝트 관리는 제한된 시간, 비용으로 좋은 품질의 시스템 개발하여 고객에게 제공

SW 재공학 주요 활동 중, 기존 SW 시스템을 새로운 기술, HW 환경에서 사용 가능하도록 변환하는 작업 (No.26 -> 2)
1. Analysis
2. Migration
3. Restructuring
4. Reverse Engineering

= 1. Analysis -> 기존 SW 분석, 재공학 대상 선정
= 2. Migration -> 기존 SW, 다른 OS, HW 환경에서 사용 가능하도록 변환하는 작업
= 3. Restructuring -> 기존 SW 향상, 코드 재구성하는 작업 (기능과 외적 동작 변하지 않음)
= 4. Reverse Engineering -> 기존 SW 분석, 소스코드 획득 작업 (소스코드로 SW 를 만들어 작업의 역작업)

정보시스템 개발 단계에서 프로그래밍 언어 선택 시 고려할 사항으로 가장 거리가 먼 것 (No.28 -> 4)
1. 개발 정보시스템 특성
2. 사용자 요구사항
3. 컴파일러 가용성
4. 컴파일러 독창성

= 프로그래밍 언어 선정 기준
  -> 1. 친밀감, 언어의 능력, 처리 효율성, 프로그램 구조, 프로그램 길이, 이식성, 과거 개발 실적
  -> 2. 알고리즘 & 계산상 난이도, 자료 구조 난이도, 성능 고려 사항들, 대상 업무 성격, SW 수행 환경
  -> 3. 개발 담당자 경험과 지식, 사용자 요구사항, 컴파일러 이용 가능성

SW 패키징에 대한 설명으로 틀린 것 (No.29 -> 1)
1. 패키징은 개발자 중심으로 진행
2. 신규 및 변경 개발소스를 식별, 모듈화, 상용 제품으로 패키징
3. 고객 편의성 위해 매뉴얼 및 버전관리를 지속적으로 함
4. 범용 환경에서 사용 가능하도록 일반적인 배포 형태로 패키징 진행

= 1. SW 패키징은 소비자 중심으로 진행
= 2. 모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일 만드는 것
= 3. 소스 코드는 향후 관리를 고려, 모듈화, 패키징
= 4. 사용자, SW 사용할 환경 이해, 다양한 환경, SW 손쉽게 사용, 일반적인 배포 형태로 패키징
= 5. 사용자 중심 진행 작업, 사용자 편의성, 실행 환경을 우선적으로 고려

아주 오래, 참고문서 또는 개발자 없어 유지보수 작업 아주 어려운 프로그램 의미하는 것 (No.31 -> 4)
1. Title Code
2. Source Code
3. Object Code
4. Alien Code

= Alien Code -> 개발자 퇴사, 현재 사용 X 환경 & 언어로 작성, 프로그램 관련 문서, 주석 X, 유지보수 불가능

인터페이스 간의 통신을 위해 이용되는 데이터 포맷이 아닌 것 (No.33 -> 1)
1. AJTML
2. JSON
3. XML
4. YAML

= 1. JSON (JS Object Notation)
  -> 속상-값 쌍, "키-값 쌍", Data Object 전달, 인간 가독 Test, 개방형 표준 포맷, AJAX, XML

= 2. XML (Extensible Markup Language)
  -> HTML 단점 보완, 인터넷 언어, SGML 복잡한 담점 개선, 특수 목적을 갖는 Markup 언어

= 3. AJAX (Asynchronous JS and XML)
  -> JS 사용, 웹 서버, 클라이언트 비동기, XML 데이터 교환 & 조작, XMLHttpRequest -> 필요한 부분만 로드

= 4. REST (Representational State Transfer)
  -> 1. 웹, 분산 HyperMedia 환경, 자원 존재/상태 정보 표준화된 HTTP Method 로 주고받는 웹 아키텍처
  -> 2. 리소스, 메서드, 메시지
  -> HTTP URI 자원 명시, HTTP Method (POST, GET, PUT, DELETE), 	SW 아키텍처

= 5. YAML 
  -> 1. JSON 과 비슷, 사람 가독, Data 표현 형식
  -> 2. XML 과 문법 유사, 주석 사용 가능 & 개행, 공백 블록 인식
  -> 3. 태그 사용 X, 공백 위주로 데이터 구분, 한 줄로 작성 불가

프로그램 설계도 하나인 NS Chart 에 대한 설명으로 가장 거리가 먼 것 (No.34 -> 3)
1. 논리 기술에 중점 두고, 도형 이용한 표현 방법
2. 이해 & 코드 변환 용이
3. 화살표, GOTO 사용하여 이해 쉬움
4. 연속, 선택, 반복 등 제어 논리 구조 표현

= 1. 3가지 기본 구조만으로 논리 표현 (표준화 가능)
= 2. Flow Chart 최대 단점인 화살표 표시 안됨
= 3. 기본구조 입구와 출구는 각 하나씩, 전체적인 알고리즘을 일목요연하게 볼 수 있음

순서가 A, B, C, D 로 정해진 입력자료, push, push, pop, push, push, pop, pop, pop (No.35 -> 1)
1. B D C A
2. A B C D
3. B A C D
4. A B D C

= 스택 연산 -> 입구 및 출구가 하나 A B C D 순으로 입력, 출력 순서 -> D C B A 순


