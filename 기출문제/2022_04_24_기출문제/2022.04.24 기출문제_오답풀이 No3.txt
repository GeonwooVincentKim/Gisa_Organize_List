다음 조건을 모두 만족하는 정규형 (No.41 -> 1)
- 1. Table R 에 속한 모든 도메인이 원자 값만으로 구성되어 있음
- 2. Table R 에서 Key 아닌 모든 Field 가 Key 에 대해 함수적 종속, Key 부분 집합이 결정자가 되는 부분 종속 존재 X
- 3. Table R 에 존재하는 모든 함수적 종속에서 결정자가 후보키

1. BCNF
2. 제1정규형
3. 제2정규형
4. 제3정규형

<도부이결다조>
= 1. 1NF -> 모든 *도* 메인이 원자 값으로 구성
= 2. 2NF -> 기본키 아닌 속성, 기본키에 대한 완전 함수적 종속을 만족, *부* 분적 함수 종속 제거한 정규형
= 3. 3NF -> 기본키 아닌 모든 속성, 기본키에 대해 *이* 행적 함수 종속 관계 만족하지 않는 정규형
= 4. BCNF -> 모든 *결* 정자가 후보키인, 정규형, 종속성 보존 X
= 5. 4NF -> *다* 치 종속 성립, R 의 모든 속성이 A 에 함수적 종속 관계 만족
= 6. 5NF -> 모든 *조* 인 종속이 R 의 후보키를 통해서만 성립되는 정규형

-> "결정자" 라는 키워드 존재 = BCNF

물리적 DB 구조의 기본 Data 단위인 저장 Record 의 양식을 설계할 때, 고려 사항이 아닌 것 (No.46)
1. 데이터 타입
2. 데이터 값 분포
3. 트랜잭션 모델링
4. 접근 빈도

= 1. 저장 레코드 양식 설계 시 고려 사항 -> Data Type, Data 값의 분포, 접근 빈도
= 2. 트랜잭션 모델링
  -> 1. 트랜잭션을 개념적 시스템 독립적으로 정의
  -> 2. 트랜잭션의 입출력 기능, 형태만 정의
  -> 3. 검색, 갱신, 혼합 (검색, 갱신)

= 3. 트랜잭션 모델링은 개념적 설계 단계에서 하는 것

트랜잭션 상태 중, 마지막 연산 실행 직후의 상태, 모든 연산 처리는 끝났지만, 트랜잭션 수행 최종결과 반영 X (No.51 -> 2)

1. Active
2. Partially Committed
3. Committed
4. Aborted

= 1. Partially Committed -> 마지막 연산이 실행된 직후의 상태, 아직 Commit 연산 실행 전
= 2. Committed -> 트랜잭션이 실행을 성공적으로 완료, Commit 연산을 수행한 상태

키의 종류 중 유일성과 최소성을 만족하는 속성 또는 속성들의 집합 (No.53 -> 3)
1. Atomic Key
2. Super Key
3. Candidate Key
4. Test Key

= 1. Super Key -> 속성들의 집합으로 구성된 Key, Relation 구성 모든 튜플들, 슈퍼키 구성, 속성 집합과 동일 값 X
= 2. Candidate Key -> Tuple 을 유일 식별 위해 사용되는 속성들의 부분 집합

DB 에서 개념적 설계 단계에 대한 설명으로 틀린 것 (No.54 -> 3)
1. 산출물로 ER Diagram 생성 가능
2. DBMS 에 독립적인 개념 스키마 설계
3. 트랜잭션 인터페이스를 설계 및 작성
4. 논리적 설계 단계의 앞 단계에서 수행

= 1. DB 설계단계에서의 트랜잭션 설계단계
  -> 1. 개념 설계 => 트랜잭션 모델링
  -> 2. 논리 설계 => 트랜잭션 인터페이스 설계
  -> 3. 물리 설계 => 트랜잭션 세부설계

= 2. 개념적 설계 => 트랜잭션 모델링 / 독립적 개념 스키마 모델링 / 개념스키마 설계 / ER Diagram
= 3. 논리적 설계 => 트랜잭션 인터페이스 설계 / DBMS 논리스키마 설계 / 테이블 / 논리적 매핑 / 스키마 평가 정제
= 4. 물리적 설계 => 레코드 집중 분석, 설계 / 저장레코드 양식 설계 / 저장 구조 및 액세스 경로 설정
